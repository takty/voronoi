var $=Object.defineProperty;var R=f=>{throw TypeError(f)};var j=(f,t,s)=>t in f?$(f,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):f[t]=s;var k=(f,t,s)=>j(f,typeof t!="symbol"?t+"":t,s),K=(f,t,s)=>t.has(f)||R("Cannot "+s);var o=(f,t,s)=>(K(f,t,"read from private field"),s?s.call(f):t.get(f)),g=(f,t,s)=>t.has(f)?R("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(f):t.set(f,s),z=(f,t,s,e)=>(K(f,t,"write to private field"),e?e.call(f,s):t.set(f,s),s),w=(f,t,s)=>(K(f,t,"access private method"),s);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const r of i.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&e(r)}).observe(document,{childList:!0,subtree:!0});function s(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerPolicy&&(i.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?i.credentials="include":n.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function e(n){if(n.ep)return;n.ep=!0;const i=s(n);fetch(n.href,i)}})();class d{constructor(t,s,e){this.x=t,this.y=s,this.z=e}}var N,B,O,L,U,W;class A{constructor(t,s){g(this,U);g(this,N);g(this,B);g(this,O);g(this,L);const e=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);z(this,N,s.x/e),z(this,B,s.y/e),z(this,O,s.z/e),z(this,L,-o(this,N)*t.x-o(this,B)*t.y-o(this,O)*t.z)}side(t){const s=o(this,N)*t.x+o(this,B)*t.y+o(this,O)*t.z+o(this,L);return s<-.001?-1:s>.001?1:0}sides(t){const s=new Map;for(const e of t)s.set(e,this.side(e));return s}intersections(t){const s=new Map;for(const e of t){if(e.pair==null||s.has(e))continue;const n=w(this,U,W).call(this,e.getBegin(),e.getEnd());n!==null&&(s.set(e,n),s.set(e.pair,n))}return s}}N=new WeakMap,B=new WeakMap,O=new WeakMap,L=new WeakMap,U=new WeakSet,W=function(t,s){const e=o(this,N)*(t.x-s.x)+o(this,B)*(t.y-s.y)+o(this,O)*(t.z-s.z);if(e<.001&&e>-.001)return null;const n=(o(this,N)*t.x+o(this,B)*t.y+o(this,O)*t.z+o(this,L))/e;return n<0||n>1?null:new d(t.x+n*(s.x-t.x),t.y+n*(s.y-t.y),t.z+n*(s.z-t.z))};var V;class I{constructor(t){g(this,V);k(this,"next");k(this,"pair",null);z(this,V,t)}getBegin(){return o(this,V)}getEnd(){return o(this.next,V)}}V=new WeakMap;var P,E,D,X,Y;class F{constructor(t){g(this,E);g(this,P);const s=t.length;for(let e=0;e<s-1;++e)t[e].next=t[e+1];t[s-1].next=t[0],z(this,P,t[0])}verticesOf(t,s,e){const n=[];let i=o(this,P);do{const r=i.getBegin();s.get(r)*t>=0&&n.push(r),e.has(i)&&n.push(e.get(i)),i=i.next}while(i!==o(this,P));return n}getGridPoints(t,s,e){const n=[],i=o(this,P).getBegin().z,r=w(this,E,D).call(this,t,s,e);for(const h of r)n.push([h,s,i]);for(let h=1;;++h){const u=n.length,a=s+h*e,c=w(this,E,D).call(this,t,a,e);for(const x of c)n.push([x,a,i]);const l=s+-h*e,p=w(this,E,D).call(this,t,l,e);for(const x of p)n.push([x,l,i]);if(n.length===u)break}return n}}P=new WeakMap,E=new WeakSet,D=function(t,s,e){const n=[],i=w(this,E,X).call(this,s);if(i.length!==2)return n;let r=i[0],h=i[1];if(r>h){const u=r;r=h,h=u}r<t&&t<h&&n.push(t);for(let u=1;;++u){const a=n.length,c=t+u*e;r<c&&c<h&&n.push(c);const l=t+-u*e;if(r<l&&l<h&&n.push(l),n.length===a)break}return n},X=function(t){const s=[];for(let e=o(this,P);;e=e.next){const n=w(this,E,Y).call(this,e,t);if(Number.isNaN(n)||s.push(n),e.next===o(this,P))break}return s},Y=function(t,s){const e=t.getBegin(),n=t.getEnd();if(s<Math.min(e.y,n.y)||Math.max(e.y,n.y)<s)return Number.NaN;const i=n.y-e.y,r=-(n.x-e.x),h=-i*e.x-r*e.y;return Math.abs(i)<1e-4?Number.NaN:-(r*s+h)/i};var M,m,b,C,q;const J=class J{constructor(){g(this,C);g(this,M,[]);g(this,m,[]);g(this,b,[])}buildMesh(t,s){for(const e of t)o(this,M).push(e);for(const e of s){const n=[];for(const i of e){const r=new I(o(this,M)[i]);n.push(r),o(this,m).push(r)}o(this,b).push(new F(n))}w(this,C,q).call(this,o(this,m))}splitMesh(t,s){const e=t.side(s);if(e===0)return;const n=[],i=[],r=[],h=t.sides(o(this,M)),u=t.intersections(o(this,m));for(const c of o(this,b)){const l=c.verticesOf(e,h,u);if(l.length>2){const p=[];for(const x of l){n.includes(x)||n.push(x);const Q=new I(x);p.push(Q),r.push(Q)}i.push(new F(p))}}w(this,C,q).call(this,r);const a=r.find(c=>c.pair===null);if(a){const c=[];let l=a;do{let p=l.next.pair.next;for(;p.pair!==null;)p=p.pair.next;const x=new I(p.getBegin());c.push(x)}while(l!==a);c.reverse(),i.push(new F(c)),r.push(...c)}z(this,M,n),z(this,b,i),z(this,m,r)}crossSection(t,s){const e=new J,n=new A(t,s),i=n.side(new d(t.x+s.x,t.y+s.y,t.z+s.z));if(i===0)return null;const r=n.sides(o(this,M)),h=n.intersections(o(this,m));if(h.size===0)return null;for(const a of o(this,b)){const c=a.verticesOf(i,r,h);if(c.length>2){const l=[];for(const p of c){o(e,M).includes(p)||o(e,M).push(p);const x=new I(p);l.push(x),o(e,m).push(x)}o(e,b).push(new F(l))}}w(this,C,q).call(this,o(e,m));const u=o(e,m).find(a=>a.pair===null);if(u){const a=[];let c=u;do{if(c.next===null||c.next.pair===null||c.next.pair.next===null)break;let l=c.next.pair.next;for(;l!==null&&l.pair;)l=l.pair.next;const p=new I(l.getBegin());a.push(p),p.pair=c,c.pair=p,c=l}while(c!==u);if(a.length>2)return new F(a.reverse())}return null}};M=new WeakMap,m=new WeakMap,b=new WeakMap,C=new WeakSet,q=function(t){for(const s of t)if(s.pair===null){for(const e of t)if(!(s===e||e.pair!==null)&&s.getBegin()===e.getEnd()&&e.getBegin()===s.getEnd()){s.pair=e,e.pair=s;break}}};let H=J;var v,y,S,G,Z,_;class T{constructor(t,s,e,n,i,r){g(this,G);g(this,v);g(this,y,[]);g(this,S,[]);z(this,v,[new d(s,n,r),new d(t,n,r),new d(t,n,i),new d(s,n,i),new d(s,e,r),new d(t,e,r),new d(t,e,i),new d(s,e,i)])}addSite(t){o(this,y).push(new d(...t))}createCells(t=null,s=null){w(this,G,Z).call(this),w(this,G,_).call(this,t,s)}calcGrids(t,s){const e=[],n=o(this,S)[t],i=o(this,y)[t],r=new d(0,0,1),h=n.crossSection(new d(0,0,i.z),r);h!=null&&e.push(...h.getGridPoints(i.x,i.y,s));for(let u=1;;++u){const a=e.length,c=n.crossSection(new d(0,0,i.z+u*s),r);c!=null&&e.push(...c.getGridPoints(i.x,i.y,s));const l=n.crossSection(new d(0,0,i.z+-u*s),r);if(l!=null&&e.push(...l.getGridPoints(i.x,i.y,s)),e.length===a)break}return e}}v=new WeakMap,y=new WeakMap,S=new WeakMap,G=new WeakSet,Z=function(){const t=[[0,1,2,3],[1,0,4,5],[0,3,7,4],[2,1,5,6],[5,4,7,6],[3,2,6,7]];for(const s of o(this,y)){const e=new H;e.buildMesh(o(this,v),t),o(this,S).push(e)}},_=function(t=null,s=null){if(!t&&!s)for(const[e,n]of o(this,y).entries())for(const i of o(this,y)){if(n===i)continue;const r=new d((n.x+i.x)*.5,(n.y+i.y)*.5,(n.z+i.z)*.5),h=new A(r,new d(n.x-i.x,n.y-i.y,n.z-i.z));o(this,S)[e].splitMesh(h,n)}else if(t&&!s)for(const[e,n]of o(this,y).entries())for(let i of t[e]){const r=o(this,y)[i],h=new d((n.x+r.x)*.5,(n.y+r.y)*.5,(n.z+r.z)*.5),u=new A(h,new d(n.x-r.x,n.y-r.y,n.z-r.z));o(this,S)[e].splitMesh(u,n)}else if(t&&s)for(const[e,n]of o(this,y).entries()){const i=t[e],r=s[e];for(let h=0;h<i.length;++h){const u=o(this,y)[i[h]],a=r[h],c=1-a,l=new d(n.x*c+u.x*a,n.y*c+u.y*a,n.z*c+u.z*a),p=new A(l,new d(n.x-u.x,n.y-u.y,n.z-u.z));o(this,S)[e].splitMesh(p,n)}}};document.addEventListener("DOMContentLoaded",()=>{const f=[[Math.random()*200-100,Math.random()*200-100,Math.random()*200-100],[Math.random()*200-100,Math.random()*200-100,Math.random()*200-100]],t=new T(-100,100,-100,100,-100,100);for(const s of f)t.addSite(s);t.createCells();for(let s=0;s<f.length;++s)console.log(t.calcGrids(s,5).length)});
