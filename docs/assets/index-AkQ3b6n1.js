(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const i of n)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(n){const i={};return n.integrity&&(i.integrity=n.integrity),n.referrerPolicy&&(i.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?i.credentials="include":n.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(n){if(n.ep)return;n.ep=!0;const i=e(n);fetch(n.href,i)}})();function k(u,t){return[u[0]+t[0],u[1]+t[1],u[2]+t[2]]}function b(u,t){return[u[0]-t[0],u[1]-t[1],u[2]-t[2]]}function S(u,t,e=.5){const s=1-e;return[u[0]*s+t[0]*e,u[1]*s+t[1]*e,u[2]*s+t[2]*e]}class p{static E=.001;#t;#s;#e;#n;constructor(t,e){const s=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);this.#t=e[0]/s,this.#s=e[1]/s,this.#e=e[2]/s,this.#n=-this.#t*t[0]-this.#s*t[1]-this.#e*t[2]}side(t){const e=this.#t*t[0]+this.#s*t[1]+this.#e*t[2]+this.#n;return e<-.001?-1:e>p.E?1:0}sides(t){const e=new Map;for(const s of t)e.set(s,this.side(s));return e}#i(t,e){const s=this.#t*(t[0]-e[0])+this.#s*(t[1]-e[1])+this.#e*(t[2]-e[2]);if(Math.abs(s)<.001)return null;const n=(this.#t*t[0]+this.#s*t[1]+this.#e*t[2]+this.#n)/s;return n<0||1<n?null:[t[0]+n*(e[0]-t[0]),t[1]+n*(e[1]-t[1]),t[2]+n*(e[2]-t[2])]}intersections(t){const e=new Map;for(const s of t){if(e.has(s))continue;const n=this.#i(s.getBegin(),s.getEnd());n&&(e.set(s,n),s.pair&&e.set(s.pair,n))}return e}}class m{#t;#s;next=null;pair=null;constructor(t){this.#t=t}setNext(t){this.next=t,this.#s=t.#t}getBegin(){return this.#t}getEnd(){return this.#s}}class l{static E=.001;#t;constructor(t){const e=t.length;for(let s=0;s<e-1;++s)t[s].setNext(t[s+1]);t[e-1].setNext(t[0]),this.#t=t[0]}length(){let t=0,e=this.#t;do t+=1,e=e.next;while(e!==this.#t);return t}verticesOf(t,e,s){const n=[];let i=this.#t;do{const o=i.getBegin();e.get(o)*t>=0&&n.push(o),s.has(i)&&n.push(s.get(i)),i=i.next}while(i!==this.#t);return n}countGridPoints(t,e,s){let n=0;const i=this.#s(t,e,s);n+=i;for(let o=1;;++o){const r=this.#s(t,e+o*s,s);if(r===0)break;n+=r}for(let o=1;;++o){const r=this.#s(t,e-o*s,s);if(r===0)break;n+=r}return n}#s(t,e,s){const n=this.#n(e);let[i,o]=n;i>o&&([i,o]=[o,i]);let r=0;i<t&&t<o&&(r+=1);for(let c=1;;++c){const h=r,f=t+c*s;if(i<f&&f<o&&(r+=1),r===h)break}for(let c=1;;++c){const h=r,f=t-c*s;if(i<f&&f<o&&(r+=1),r===h)break}return r}getGridPoints(t,e,s){const n=[],i=this.#t.getBegin()[2],o=this.#e(t,e,s);for(const r of o)n.push([r,e,i]);for(let r=1;;++r){const c=e+r*s,h=this.#e(t,c,s);if(h.length===0)break;for(const f of h)n.push([f,c,i])}for(let r=1;;++r){const c=e-r*s,h=this.#e(t,c,s);if(h.length===0)break;for(const f of h)n.push([f,c,i])}return n}#e(t,e,s){const n=this.#n(e);let[i,o]=n;i>o&&([i,o]=[o,i]);const r=[];i<t&&t<o&&r.push(t);for(let c=1;;++c){const h=r.length,f=t+c*s;if(i<f&&f<o&&r.push(f),r.length===h)break}for(let c=1;;++c){const h=r.length,f=t-c*s;if(i<f&&f<o&&r.push(f),r.length===h)break}return r}#n(t){const e=[];for(let s=this.#t;;s=s.next){const n=l.#i(s,t);if(e.push(...n),s.next===this.#t)break}return l.#o(e)}static#i(t,e){const[s,n]=t.getBegin(),[i,o]=t.getEnd();if(e<Math.min(n,o)||Math.max(n,o)<e)return[];if(Math.abs(n-o)<l.E)return[s,i];const r=o-n,c=-(i-s),h=-r*s-c*n;return Math.abs(r)<l.E?[]:[-(c*e+h)/r]}static#o(t){if(t.length===0)return[];t.sort((n,i)=>n-i);const e=[];let s=t[0];for(let n=1;n<t.length;n++)l.E<t[n]-t[n-1]&&(e.push(s),s=t[n]);return e.push(s),e}}class d{#t=[];#s=[];#e=[];static buildMesh(t,e){const s=new d;for(const n of t)s.#t.push([...n]);for(const n of e){const i=[];for(const o of n)i.push(new m(s.#t[o]));s.#s.push(...i),s.#e.push(new l(i))}return d.#n(s.#s),s}static#n(t){for(const e of t)if(e.pair===null){for(const s of t)if(!(e===s||s.pair!==null)&&e.getBegin()===s.getEnd()&&s.getBegin()===e.getEnd()){e.pair=s,s.pair=e;break}}}constructor(){}splitMesh(t,e){const s=t.side(e);if(s===0)return;const n=t.intersections(this.#s);if(n.size===0)return;const i=t.sides(this.#t),o=[],r=[],c=[];for(const f of this.#e){const g=f.verticesOf(s,i,n);if(g.length<=2)continue;const a=[];for(const E of g)o.includes(E)||o.push(E),a.push(new m(E));r.push(...a),c.push(new l(a))}d.#n(r);const h=r.filter(f=>f.pair===null);if(h.length>0){const f=d.#i(h);r.push(...f),c.push(new l(f))}this.#t=o,this.#e=c,this.#s=r}crossSection(t,e){const s=new p(t,e),n=s.side(k(t,e));if(n===0)return null;const i=s.intersections(this.#s);if(i.size===0)return null;const o=s.sides(this.#t),r=[],c=[];for(const f of this.#e){const g=f.verticesOf(n,o,i);if(g.length<=2)continue;const a=[];for(const E of g)a.push(new m(E));r.push(...a),c.push(new l(a))}d.#n(r);const h=r.filter(f=>f.pair===null);if(h.length>0){const f=d.#i(h);if(f.length>2)return new l(f)}return null}static#i(t){const e=[];let s=t[0];do{if(s.next===null)break;let n=s.next;for(;n&&!t.includes(n);)n=n.pair.next;const i=new m(n.getBegin());e.push(i),i.pair=s,s.pair=i,s=n}while(s!==t[0]);return e.reverse(),e}}class w{static FACE_INDEXES=[[0,1,2,3],[1,0,4,5],[0,3,7,4],[2,1,5,6],[5,4,7,6],[3,2,6,7]];#t;#s=[];#e=[];constructor(t,e,s,n,i,o){this.#t=[[e,n,o],[t,n,o],[t,n,i],[e,n,i],[e,s,o],[t,s,o],[t,s,i],[e,s,i]]}addSite(t){this.#s.push([...t])}createCells(t=null,e=null){this.#e.length=0,!t&&!e?this.#n():t&&!e?this.#i(t):t&&e&&this.#o(t,e)}#n(){for(const t of this.#s){const e=d.buildMesh(this.#t,w.FACE_INDEXES);for(const s of this.#s){if(t===s)continue;const n=new p(S(t,s),b(t,s));e.splitMesh(n,t)}this.#e.push(e)}}#i(t){for(const[e,s]of this.#s.entries()){const n=d.buildMesh(this.#t,w.FACE_INDEXES);for(let i of t[e]){const o=this.#s[i],r=new p(S(s,o),b(s,o));n.splitMesh(r,s)}this.#e.push(n)}}#o(t,e){for(const[s,n]of this.#s.entries()){const i=d.buildMesh(this.#t,w.FACE_INDEXES),o=t[s],r=e[s];for(let c=0;c<o.length;++c){const h=this.#s[o[c]],f=new p(S(n,h,r[c]),b(n,h));i.splitMesh(f,n)}this.#e.push(i)}}countGrids(t,e){let s=0;const n=[0,0,1],i=this.#s[t],o=this.#e[t],r=o.crossSection([0,0,i[2]],n);if(r){const c=r.countGridPoints(i[0],i[1],e);s+=c}for(let c=1;;++c){const h=o.crossSection([0,0,i[2]+c*e],n);if(!h)break;const f=h.countGridPoints(i[0],i[1],e);if(!f)break;s+=f}for(let c=1;;++c){const h=o.crossSection([0,0,i[2]-c*e],n);if(!h)break;const f=h.countGridPoints(i[0],i[1],e);if(!f)break;s+=f}return s}getGrids(t,e){const s=[],n=[0,0,1],i=this.#s[t],o=this.#e[t],r=o.crossSection([0,0,i[2]],n);r&&s.push(...r.getGridPoints(i[0],i[1],e));for(let c=1;;++c){const h=o.crossSection([0,0,i[2]+c*e],n);if(!h)break;const f=h.getGridPoints(i[0],i[1],e);if(!f.length)break;s.push(...f)}for(let c=1;;++c){const h=o.crossSection([0,0,i[2]-c*e],n);if(!h)break;const f=h.getGridPoints(i[0],i[1],e);if(!f.length)break;s.push(...f)}return s}}document.addEventListener("DOMContentLoaded",()=>{P()});function P(){const u=[[[0,3,1],[2,0,2]],[[0,0,1],[3,2,2]],[[0,1,0],[2,2,3]],[[2,3,0],[1,0,2]]];for(const t of u){const e=new w(0,3,0,3,0,3);for(const n of t)e.addSite(n);e.createCells();let s=0;for(let n=0;n<t.length;++n){const i=e.countGrids(n,.1);console.log(t[n].toString(),i),s+=i}console.log(s)}}
