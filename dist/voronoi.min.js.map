{
  "version": 3,
  "sources": ["../src/vertex.ts", "../src/plane.ts", "../src/edge.ts", "../src/face.ts", "../src/mesh.ts", "../src/voronoi.ts"],
  "sourcesContent": ["/**\r\n * Vertex\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-11-19\r\n */\r\n\r\nexport type Vertex = [number, number, number];\r\n\r\nexport function add(a: Vertex, b: Vertex): Vertex {\r\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\r\n}\r\n\r\nexport function sub(a: Vertex, b: Vertex): Vertex {\r\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\r\n}\r\n\r\nexport function intDiv(a: Vertex, b: Vertex, m: number = 0.5): Vertex {\r\n\tconst n: number = 1 - m;\r\n\treturn [\r\n\t\ta[0] * n + b[0] * m,\r\n\t\ta[1] * n + b[1] * m,\r\n\t\ta[2] * n + b[2] * m,\r\n\t];\r\n}\r\n", "/**\r\n * Plane\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-11-22\r\n */\r\n\r\nimport { Vertex } from './vertex';\r\nimport { Edge } from './edge';\r\n\r\n/**\r\n * Represents a plane in 3D space defined by the equation AX + BY + CZ + D = 0.\r\n * This class provides methods to calculate the side of a point relative to the plane,\r\n * and to find intersections of edges or vertices with the plane.\r\n */\r\nexport class Plane {\r\n\r\n\tstatic readonly E: number = 0.001;\r\n\r\n\t#A: number;\r\n\t#B: number;\r\n\t#C: number;\r\n\t#D: number;\r\n\r\n\t/**\r\n\t * Creates a plane from a specified center point and a direction vector.\r\n\t * The direction vector (from p0 to p1) defines the plane's orientation.\r\n\t *\r\n\t * @param p0 - The center point on the plane.\r\n\t * @param p1 - A point determining the direction vector of the plane.\r\n\t */\r\n\tconstructor(p0: Vertex, p1: Vertex) {\r\n\t\tconst len: number = Math.sqrt(p1[0] * p1[0] + p1[1] * p1[1] + p1[2] * p1[2]);\r\n\t\tthis.#A = p1[0] / len;\r\n\t\tthis.#B = p1[1] / len;\r\n\t\tthis.#C = p1[2] / len;\r\n\t\tthis.#D = - this.#A * p0[0] - this.#B * p0[1] - this.#C * p0[2];\r\n\t}\r\n\r\n\t/**\r\n\t * Determines the relative position of a given vertex to the plane.\r\n\t * Returns -1 if the point is below the plane, 1 if above, and 0 if on the plane.\r\n\t *\r\n\t * @param p - The vertex to evaluate.\r\n\t * @returns -1, 0, or 1 indicating the side of the plane the vertex is on.\r\n\t */\r\n\tside(p: Vertex): -1 | 0 | 1 {\r\n\t\tconst t: number = this.#A * p[0] + this.#B * p[1] + this.#C * p[2] + this.#D;\r\n\t\tif (t < -Plane.E) return -1;\r\n\t\tif (t > Plane.E) return 1;\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the side of each vertex in a list relative to the plane.\r\n\t *\r\n\t * @param vs - An array of vertices to evaluate.\r\n\t * @returns A map of each vertex to its side relative to the plane.\r\n\t */\r\n\tsides(vs: Vertex[]): Map<Vertex, number> {\r\n\t\tconst sides: Map<Vertex, number> = new Map();\r\n\r\n\t\tfor (const v of vs) {\r\n\t\t\tsides.set(v, this.side(v));\r\n\t\t}\r\n\t\treturn sides;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the intersection point of a line segment with the plane, if any.\r\n\t * The line segment is defined by two vertices, and the intersection point\r\n\t * is returned if it lies within the segment bounds.\r\n\t *\r\n\t * @param v0 - The starting vertex of the line segment.\r\n\t * @param v1 - The ending vertex of the line segment.\r\n\t * @returns The intersection vertex if it exists within the segment, otherwise null.\r\n\t */\r\n\t#intersection(v0: Vertex, v1: Vertex): Vertex | null {\r\n\t\tconst d: number = this.#A * (v0[0] - v1[0]) + this.#B * (v0[1] - v1[1]) + this.#C * (v0[2] - v1[2]);\r\n\t\tif (Math.abs(d) < 0.001) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tconst u: number = (this.#A * v0[0] + this.#B * v0[1] + this.#C * v0[2] + this.#D) / d;\r\n\t\tif (u < 0 || 1 < u) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn [v0[0] + u * (v1[0] - v0[0]), v0[1] + u * (v1[1] - v0[1]), v0[2] + u * (v1[2] - v0[2])];\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates intersection points of a list of edges with the plane.\r\n\t * Each intersection is stored for both the edge and its paired edge if applicable.\r\n\t *\r\n\t * @param es - An array of edges to check for intersections with the plane.\r\n\t * @returns A map of each edge to its intersection vertex, if any.\r\n\t */\r\n\tintersections(es: Edge[]): Map<Edge, Vertex> {\r\n\t\tconst ret: Map<Edge, Vertex> = new Map();\r\n\r\n\t\tfor (const e of es) {\r\n\t\t\tif (ret.has(e)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconst v: Vertex | null = this.#intersection(e.getBegin(), e.getEnd() as Vertex);\r\n\t\t\tif (v) {\r\n\t\t\t\tret.set(e, v);\r\n\t\t\t\tif (e.pair) {\r\n\t\t\t\t\tret.set(e.pair, v);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Edge\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-11-19\r\n */\r\n\r\nimport { Vertex } from './vertex';\r\n\r\n/**\r\n * Represents an edge in a geometric structure, connecting two vertices.\r\n * Each edge may have a paired edge in the opposite direction and a next edge within the same face.\r\n */\r\nexport class Edge {\r\n\r\n\t#bgn: Vertex;\r\n\t#end!: Vertex;\r\n\r\n\t/**\r\n\t * The next edge in the same face\r\n\t */\r\n\tpublic next: Edge | null = null;\r\n\r\n\t/**\r\n\t * The paired edge in the opposite direction\r\n\t */\r\n\tpublic pair: Edge | null = null;\r\n\r\n\t/**\r\n\t * Creates an instance of Edge with the specified beginning vertex.\r\n\t *\r\n\t * @param v - The starting vertex of this edge.\r\n\t */\r\n\tconstructor(v: Vertex) {\r\n\t\tthis.#bgn = v;\r\n\t}\r\n\r\n\tsetNext(e: Edge): void {\r\n\t\tthis.next = e;\r\n\t\tthis.#end = e.#bgn;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the starting vertex of this edge.\r\n\t *\r\n\t * @returns The starting vertex of the edge.\r\n\t */\r\n\tgetBegin(): Vertex {\r\n\t\treturn this.#bgn;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the ending vertex of this edge.\r\n\t *\r\n\t * @returns The ending vertex of the edge, defined as the starting vertex of the next edge.\r\n\t */\r\n\tgetEnd(): Vertex {\r\n\t\treturn this.#end;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Face\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-11-22\r\n */\r\n\r\nimport { Vertex } from './vertex';\r\nimport { Edge } from './edge';\r\n\r\n/**\r\n * Represents a face in a geometric structure, composed of edges that form a closed loop.\r\n * Each face has a reference to its first edge and provides methods to calculate points\r\n * within or along its edges in a plane.\r\n */\r\nexport class Face {\r\n\r\n\tstatic readonly E: number = 0.001;\r\n\r\n\t#firstEdge: Edge;\r\n\r\n\t/**\r\n\t * Creates an instance of Face, setting up the circular linkage of edges\r\n\t * to define a closed face.\r\n\t *\r\n\t * @param es - An array of edges that form the face.\r\n\t */\r\n\tconstructor(es: Edge[]) {\r\n\t\tconst n: number = es.length;\r\n\r\n\t\tfor (let i: number = 0; i < n - 1; ++i) {\r\n\t\t\tes[i].setNext(es[i + 1]);\r\n\t\t}\r\n\t\tes[n - 1].setNext(es[0]);\r\n\r\n\t\tthis.#firstEdge = es[0];\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the number of edges that compose this face.\r\n\t *\r\n\t * @returns The total number of edges in the face.\r\n\t */\r\n\tlength(): number {\r\n\t\tlet ret: number = 0;\r\n\t\tlet e: Edge = this.#firstEdge;\r\n\t\tdo {\r\n\t\t\tret += 1;\r\n\t\t\te = e.next as Edge;\r\n\t\t} while (e !== this.#firstEdge);\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the vertices on the specified side of the face based on a provided side reference.\r\n\t *\r\n\t * @param refSide - The reference side of the face.\r\n\t * @param vertToSide - A map associating each vertex with a specific side.\r\n\t * @param edgeToInter - A map providing intersection points for edges that intersect a plane.\r\n\t * @returns An array of vertices on the specified side of the face.\r\n\t */\r\n\tverticesOf(refSide: number, vertToSide: Map<Vertex, number>, edgeToInter: Map<Edge, Vertex>): Vertex[] {\r\n\t\tconst ret: Vertex[] = [];  // Array to store vertices on the specified side.\r\n\r\n\t\tlet e: Edge = this.#firstEdge;\r\n\t\tdo {\r\n\t\t\tconst v: Vertex = e.getBegin();\r\n\t\t\tif (vertToSide.get(v) as number * refSide >= 0) {\r\n\t\t\t\tret.push(v);  // Adds vertex on the specified side.\r\n\t\t\t}\r\n\t\t\tif (edgeToInter.has(e)) {\r\n\t\t\t\tret.push(edgeToInter.get(e) as Vertex);  // Adds intersection point of edge with plane.\r\n\t\t\t}\r\n\t\t\te = e.next as Edge;\r\n\t\t} while (e !== this.#firstEdge);\r\n\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/**\r\n\t * Counts grid points within the face restricted to a specific plane (common z-coordinate).\r\n\t *\r\n\t * @param cx - The center x-coordinate.\r\n\t * @param cy - The center y-coordinate.\r\n\t * @param resolution - The resolution of the grid.\r\n\t * @returns The count of grid points within the face.\r\n\t */\r\n\tcountGridPoints(cx: number, cy: number, resolution: number): number {\r\n\t\tlet ret: number = 0;\r\n\r\n\t\tconst pc: number = this.#countInternalPoints(cx, cy, resolution);\r\n\t\tret += pc;\r\n\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst pc: number = this.#countInternalPoints(cx, cy + inc * resolution, resolution);\r\n\t\t\tif (0 === pc) break;\r\n\t\t\tret += pc;\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst pc: number = this.#countInternalPoints(cx, cy - inc * resolution, resolution);\r\n\t\t\tif (0 === pc) break;\r\n\t\t\tret += pc;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns internal grid points along the x-axis within the boundaries of the face on a given plane.\r\n\t *\r\n\t * @param cx - The center x-coordinate.\r\n\t * @param cy - The y-coordinate.\r\n\t * @param resolution - The resolution of the grid.\r\n\t * @returns The number of internal grid points at the specified y-coordinate.\r\n\t */\r\n\t#countInternalPoints(cx: number, cy: number, resolution: number): number {\r\n\t\tconst ips: number[] = this.#getIntersectionPoints(cy);\r\n\r\n\t\tlet [x0, x1] = ips;\r\n\t\tif (x0 > x1) {\r\n\t\t\t[x0, x1] = [x1, x0];\r\n\t\t}\r\n\t\tlet pc: number = 0;\r\n\t\tif (x0 < cx && cx < x1) {\r\n\t\t\tpc += 1;\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst s: number = pc;\r\n\t\t\tconst x: number = cx + inc * resolution;\r\n\t\t\tif (x0 < x && x < x1) {\r\n\t\t\t\tpc += 1;\r\n\t\t\t}\r\n\t\t\tif (pc === s) break;\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst s: number = pc;\r\n\t\t\tconst x: number = cx - inc * resolution;\r\n\t\t\tif (x0 < x && x < x1) {\r\n\t\t\t\tpc += 1;\r\n\t\t\t}\r\n\t\t\tif (pc === s) break;\r\n\t\t}\r\n\t\treturn pc;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates grid points within the face restricted to a specific plane (common z-coordinate).\r\n\t *\r\n\t * @param cx - The center x-coordinate.\r\n\t * @param cy - The center y-coordinate.\r\n\t * @param resolution - The resolution of the grid.\r\n\t * @returns An array of 3D points within the face on the specified plane.\r\n\t */\r\n\tgetGridPoints(cx: number, cy: number, resolution: number): [number, number, number][] {\r\n\t\tconst ret: [number, number, number][] = [];\r\n\t\tconst z: number = this.#firstEdge.getBegin()[2];\r\n\r\n\t\tconst ps: number[] = this.#getInternalPoints(cx, cy, resolution);\r\n\t\tfor (const x of ps) {\r\n\t\t\tret.push([x, cy, z]);\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst y: number = cy + inc * resolution;\r\n\t\t\tconst ps: number[] = this.#getInternalPoints(cx, y, resolution);\r\n\t\t\tif (0 === ps.length) break;\r\n\t\t\tfor (const x of ps) {\r\n\t\t\t\tret.push([x, y, z]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst y: number = cy - inc * resolution;\r\n\t\t\tconst ps: number[] = this.#getInternalPoints(cx, y, resolution);\r\n\t\t\tif (0 === ps.length) break;\r\n\t\t\tfor (const x of ps) {\r\n\t\t\t\tret.push([x, y, z]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the x-coordinates of grid points within the face boundaries at a specific y-coordinate.\r\n\t *\r\n\t * @param cx - The center x-coordinate.\r\n\t * @param cy - The y-coordinate at which to compute points.\r\n\t * @param resolution - The resolution of the grid.\r\n\t * @returns An array of x-coordinates of internal grid points at the specified y-coordinate.\r\n\t */\r\n\t#getInternalPoints(cx: number, cy: number, resolution: number): number[] {\r\n\t\tconst ips: number[] = this.#getIntersectionPoints(cy);\r\n\r\n\t\tlet [x0, x1] = ips;\r\n\t\tif (x0 > x1) {\r\n\t\t\t[x0, x1] = [x1, x0];\r\n\t\t}\r\n\t\tconst pts: number[] = [];\r\n\t\tif (x0 < cx && cx < x1) {\r\n\t\t\tpts.push(cx);\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst s: number = pts.length;\r\n\t\t\tconst x: number = cx + inc * resolution;\r\n\t\t\tif (x0 < x && x < x1) {\r\n\t\t\t\tpts.push(x);\r\n\t\t\t}\r\n\t\t\tif (pts.length === s) break;\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst s: number = pts.length;\r\n\t\t\tconst x: number = cx - inc * resolution;\r\n\t\t\tif (x0 < x && x < x1) {\r\n\t\t\t\tpts.push(x);\r\n\t\t\t}\r\n\t\t\tif (pts.length === s) break;\r\n\t\t}\r\n\t\treturn pts;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the x-coordinates where the face's edges intersect a horizontal line at a specified y-coordinate.\r\n\t *\r\n\t * @param y - The y-coordinate at which to find intersections.\r\n\t * @returns An array of x-coordinates where the edges intersect the horizontal line.\r\n\t */\r\n\t#getIntersectionPoints(y: number): number[] {\r\n\t\tconst pts: number[] = [];\r\n\r\n\t\tfor (let e: Edge = this.#firstEdge; ; e = e.next as Edge) {\r\n\t\t\tconst xs: number[] = Face.#getIntersection(e, y);\r\n\t\t\tpts.push(...xs);\r\n\t\t\tif (e.next === this.#firstEdge) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn Face.#removeDuplicates(pts);\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the x-coordinate(s) where a given edge intersects a horizontal line at a specified y-coordinate.\r\n\t *\r\n\t * @param e - The edge to check for intersection.\r\n\t * @param y - The y-coordinate of the horizontal line.\r\n\t * @returns An array of x-coordinates where the edge intersects the line; empty if no intersection.\r\n\t */\r\n\tstatic #getIntersection(e: Edge, y: number): number[] {\r\n\t\tconst [x0, y0] = e.getBegin();\r\n\t\tconst [x1, y1] = e.getEnd();\r\n\r\n\t\tif (y < Math.min(y0, y1) || Math.max(y0, y1) < y) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\tif (Math.abs(y0 - y1) < Face.E) {\r\n\t\t\treturn [x0, x1];\r\n\t\t}\r\n\t\tconst A: number = y1 - y0;\r\n\t\tconst B: number = -(x1 - x0);\r\n\t\tconst C: number = - A * x0 - B * y0;\r\n\r\n\t\tif (Math.abs(A) < Face.E) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\treturn [-(B * y + C) / A];\r\n\t}\r\n\r\n\t/**\r\n\t * Removes near-duplicate numbers from an array, considering values within a small epsilon (Face.E) as duplicates.\r\n\t *\r\n\t * @param vs - An array of numbers.\r\n\t * @returns A new sorted array with near-duplicates removed.\r\n\t */\r\n\tstatic #removeDuplicates(vs: number[]): number[] {\r\n\t\tif (vs.length === 0) return [];\r\n\r\n\t\tvs.sort((a: number, b: number): number => a - b);\r\n\t\tconst res: number[] = [];\r\n\t\tlet cur: number = vs[0];\r\n\r\n\t\tfor (let i: number = 1; i < vs.length; i++) {\r\n\t\t\tif (Face.E < vs[i] - vs[i - 1]) {\r\n\t\t\t\tres.push(cur);\r\n\t\t\t\tcur = vs[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tres.push(cur);\r\n\t\treturn res;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Mesh\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2024-11-19\r\n */\r\n\r\nimport { Vertex, add } from './vertex';\r\nimport { Edge } from './edge';\r\nimport { Face } from './face';\r\nimport { Plane } from './plane';\r\n\r\n/**\r\n * Represents a mesh structure composed of vertices, edges, and faces in 3D space.\r\n * The Mesh class provides methods to build the mesh, split it along a plane, and\r\n * compute cross-sections.\r\n */\r\nexport class Mesh {\r\n\r\n\t#vs: Vertex[] = [];\r\n\t#es: Edge[]   = [];\r\n\t#fs: Face[]   = [];\r\n\r\n\t/**\r\n\t * Builds the mesh using a set of vertices and face indices.\r\n\t * Each face is formed by a series of edges created from the vertices.\r\n\t *\r\n\t * @param vs - The vertices of the mesh.\r\n\t * @param faceIndex - Array of vertex indices, where each sub-array defines the vertices of a face.\r\n\t */\r\n\tstatic buildMesh(vs: Vertex[], faceIndex: number[][]): Mesh {\r\n\t\tconst m = new Mesh();\r\n\t\tfor (const v of vs) {\r\n\t\t\tm.#vs.push([...v]);\r\n\t\t}\r\n\t\tfor (const vis of faceIndex) {\r\n\t\t\tconst faceEs: Edge[] = [];\r\n\r\n\t\t\tfor (const vi of vis) {\r\n\t\t\t\tfaceEs.push(new Edge(m.#vs[vi]));\r\n\t\t\t}\r\n\t\t\tm.#es.push(...faceEs);\r\n\t\t\tm.#fs.push(new Face(faceEs));\r\n\t\t}\r\n\t\tMesh.#pairEdges(m.#es);\r\n\t\treturn m;\r\n\t}\r\n\r\n\t/**\r\n\t * Pairs edges that are at the same position but in opposite directions.\r\n\t * This method ensures that half-edges have corresponding paired edges.\r\n\t *\r\n\t * @param es - Array of edges in the mesh.\r\n\t */\r\n\tstatic #pairEdges(es: Edge[]): void {\r\n\t\tfor (const e0 of es) {\r\n\t\t\tif (e0.pair !== null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tfor (const e1 of es) {\r\n\t\t\t\tif (e0 === e1 || e1.pair !== null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// Matching edge in opposite direction\r\n\t\t\t\tif (e0.getBegin() === e1.getEnd() && e1.getBegin() === e0.getEnd()) {\r\n\t\t\t\t\te0.pair = e1;\r\n\t\t\t\t\te1.pair = e0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconstructor() {\r\n\t}\r\n\r\n\t/**\r\n\t * Splits the mesh along a specified plane and generates new faces and vertices on one side of the plane.\r\n\t *\r\n\t * @param p - The plane to split the mesh along.\r\n\t * @param site - The reference vertex to determine which side of the plane to retain.\r\n\t */\r\n\tsplitMesh(p: Plane, site: Vertex): void {\r\n\t\tconst siteSide: number = p.side(site);\r\n\t\tif (siteSide === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst edgeToInter: Map<Edge, Vertex> = p.intersections(this.#es);\r\n\t\tif (edgeToInter.size === 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst sides: Map<Vertex, number> = p.sides(this.#vs);  // Check if each vertex is on front or back side of the plane\r\n\t\tconst newVs: Vertex[] = [];\r\n\t\tconst newEs: Edge[]   = [];\r\n\t\tconst newFs: Face[]   = [];\r\n\r\n\t\tfor (const f of this.#fs) {\r\n\t\t\tconst newFaceVs: Vertex[] = f.verticesOf(siteSide, sides, edgeToInter);\r\n\r\n\t\t\tif (newFaceVs.length <= 2) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// If there are three or more vertices on the reference side, create a new face\r\n\t\t\tconst faceEs: Edge[] = [];\r\n\r\n\t\t\tfor (const v of newFaceVs) {\r\n\t\t\t\tif (!newVs.includes(v)) {\r\n\t\t\t\t\tnewVs.push(v);\r\n\t\t\t\t}\r\n\t\t\t\tfaceEs.push(new Edge(v));\r\n\t\t\t}\r\n\t\t\tnewEs.push(...faceEs);\r\n\t\t\tnewFs.push(new Face(faceEs));\r\n\t\t}\r\n\t\tMesh.#pairEdges(newEs);\r\n\r\n\t\tconst unpairedEs: Edge[] = newEs.filter((e: Edge): boolean => e.pair === null);\r\n\r\n\t\t// Handle unpaired edges to form a closed loop, creating a new face\r\n\t\tif (unpairedEs.length > 0) {\r\n\t\t\tconst faceEs: Edge[] = Mesh.#createFaceEdgesFromUnpairedEdges(unpairedEs);\r\n\t\t\tnewEs.push(...faceEs);\r\n\t\t\tnewFs.push(new Face(faceEs));\r\n\t\t}\r\n\t\tthis.#vs = newVs;\r\n\t\tthis.#fs = newFs;\r\n\t\tthis.#es = newEs;\r\n\t}\r\n\r\n\t/**\r\n\t * Computes the cross-section of the mesh along a specified plane.\r\n\t * Returns a face that represents the cross-section if it exists.\r\n\t *\r\n\t * @param org - The origin vertex for the plane.\r\n\t * @param norm - The normal vector for the plane.\r\n\t * @returns A Face representing the cross-section or null if no intersection exists.\r\n\t */\r\n\tcrossSection(org: Vertex, norm: Vertex): Face | null {\r\n\t\tconst p       : Plane = new Plane(org, norm);\r\n\t\tconst siteSide: number = p.side(add(org, norm));\r\n\t\tif (siteSide === 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t// Determine front or back side for each vertex\r\n\t\tconst edgeToInter: Map<Edge, Vertex> = p.intersections(this.#es);\r\n\t\tif (edgeToInter.size === 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tconst sides: Map<Vertex, number> = p.sides(this.#vs);\r\n\t\tconst newEs: Edge[]   = [];\r\n\t\tconst newFs: Face[]   = [];\r\n\r\n\t\tfor (const f of this.#fs) {\r\n\t\t\tconst newFaceVs: Vertex[] = f.verticesOf(siteSide, sides, edgeToInter);\r\n\r\n\t\t\tif (newFaceVs.length <= 2) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Create a new face if there are three or more vertices on the reference side\r\n\t\t\tconst faceEs: Edge[] = [];\r\n\r\n\t\t\tfor (const v of newFaceVs) {\r\n\t\t\t\tfaceEs.push(new Edge(v));\r\n\t\t\t}\r\n\t\t\tnewEs.push(...faceEs);\r\n\t\t\tnewFs.push(new Face(faceEs));\r\n\t\t}\r\n\t\tMesh.#pairEdges(newEs);\r\n\r\n\t\tconst unpairedEs: Edge[] = newEs.filter((e: Edge): boolean => e.pair === null);\r\n\r\n\t\t// Form a closed loop with unpaired edges to create a new face if possible\r\n\t\tif (unpairedEs.length > 0) {\r\n\t\t\tconst faceEs: Edge[] = Mesh.#createFaceEdgesFromUnpairedEdges(unpairedEs);\r\n\t\t\tif (faceEs.length > 2) {\r\n\t\t\t\treturn new Face(faceEs);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tstatic #createFaceEdgesFromUnpairedEdges(unpairedEs: Edge[]): Edge[] {\r\n\t\tconst faceEs: Edge[] = [];\r\n\t\tlet e: Edge = unpairedEs[0];\r\n\t\tdo {\r\n\t\t\tif (e.next === null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tlet next: Edge = e.next;\r\n\t\t\twhile (next && !unpairedEs.includes(next)) {\r\n\t\t\t\tnext = (next.pair as Edge).next as Edge;\r\n\t\t\t}\r\n\t\t\tconst ne: Edge = new Edge(next.getBegin());\r\n\t\t\tfaceEs.push(ne);\r\n\t\t\tne.pair = e;\r\n\t\t\te.pair  = ne;\r\n\t\t\te       = next;\r\n\t\t} while (e !== unpairedEs[0]);\r\n\r\n\t\tfaceEs.reverse();\r\n\t\treturn faceEs;\r\n\t}\r\n\r\n}\r\n", "/**\r\n * Voronoi Partition\r\n * @author Takuto Yanagida\r\n * @version 2024-11-19\r\n */\r\n\r\nimport { Vertex, intDiv, sub } from './vertex';\r\nimport { Plane } from './plane';\r\nimport { Face } from './face';\r\nimport { Mesh } from './mesh';\r\n\r\n/**\r\n * Represents a Voronoi partition in 3D space. This class provides methods to create and\r\n * manage Voronoi cells using a set of sites, adjacency tables, and weight tables.\r\n * Each cell is represented as a mesh structure.\r\n */\r\nexport class Voronoi {\r\n\r\n\tstatic readonly FACE_INDEXES: number[][] = [\r\n\t\t[0, 1, 2, 3], [1, 0, 4, 5], [0, 3, 7, 4],\r\n\t\t[2, 1, 5, 6], [5, 4, 7, 6], [3, 2, 6, 7]\r\n\t];\r\n\r\n\t#defaultVs: Vertex[];\r\n\r\n\t#sites: Vertex[] = [];\r\n\t#cells: Mesh[] = [];;\r\n\r\n\t/**\r\n\t * Initializes the Voronoi partition with default vertices defining a bounding box.\r\n\t *\r\n\t * @param x0 - Minimum x-coordinate for the bounding box.\r\n\t * @param x1 - Maximum x-coordinate for the bounding box.\r\n\t * @param y0 - Minimum y-coordinate for the bounding box.\r\n\t * @param y1 - Maximum y-coordinate for the bounding box.\r\n\t * @param z0 - Minimum z-coordinate for the bounding box.\r\n\t * @param z1 - Maximum z-coordinate for the bounding box.\r\n\t */\r\n\tconstructor(x0: number, x1: number, y0: number, y1: number, z0: number, z1: number) {\r\n\t\tthis.#defaultVs = [\r\n\t\t\t[x1, y1, z1], [x0, y1, z1],\r\n\t\t\t[x0, y1, z0], [x1, y1, z0],\r\n\t\t\t[x1, y0, z1], [x0, y0, z1],\r\n\t\t\t[x0, y0, z0], [x1, y0, z0],\r\n\t\t];\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a site for the Voronoi partition.\r\n\t *\r\n\t * @param site - Coordinates of the site as a tuple [x, y, z].\r\n\t */\r\n\taddSite(site: [number, number, number]): void {\r\n\t\tthis.#sites.push([...site]);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes and creates Voronoi cells based on optionally provided adjacency and weight tables.\r\n\t *\r\n\t * @param adjacencyTable - Optional adjacency table for defining relationships between sites.\r\n\t * @param weightTable - Optional weight table that affects partitioning.\r\n\t */\r\n\tcreateCells(adjacencyTable: number[][] | null = null, weightTable: number[][] | null = null): void {\r\n\t\tthis.#cells.length = 0;\r\n\r\n\t\tif (!adjacencyTable && !weightTable) {\r\n\t\t\tthis.#divide1();\r\n\t\t} else if (adjacencyTable && !weightTable) {\r\n\t\t\tthis.#divide2(adjacencyTable);\r\n\t\t} else if (adjacencyTable && weightTable) {\r\n\t\t\tthis.#divide3(adjacencyTable, weightTable);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the Voronoi cells by splitting initial cells.\r\n\t */\r\n\t#divide1(): void {\r\n\t\tfor (const s of this.#sites) {\r\n\t\t\t// Creates initial cells as regular hexahedrons.\r\n\t\t\tconst m: Mesh = Mesh.buildMesh(this.#defaultVs, Voronoi.FACE_INDEXES);\r\n\r\n\t\t\tfor (const t of this.#sites) {\r\n\t\t\t\tif (s === t) continue;\r\n\t\t\t\tconst p: Plane = new Plane(intDiv(s, t), sub(s, t));\r\n\t\t\t\tm.splitMesh(p, s);\r\n\t\t\t}\r\n\t\t\tthis.#cells.push(m);\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * Creates the Voronoi cells by splitting initial cells based on adjacency\r\n\t * tables.\r\n\t *\r\n\t * @param adjTab - Optional adjacency table for the sites.\r\n\t */\r\n\t#divide2(adjTab: number[][]): void {\r\n\t\tfor (const [i, s] of this.#sites.entries()) {\r\n\t\t\t// Creates initial cells as regular hexahedrons.\r\n\t\t\tconst m: Mesh = Mesh.buildMesh(this.#defaultVs, Voronoi.FACE_INDEXES);\r\n\r\n\t\t\tfor (let a of adjTab[i]) {\r\n\t\t\t\tconst t: Vertex = this.#sites[a];\r\n\t\t\t\tconst p: Plane = new Plane(intDiv(s, t), sub(s, t));\r\n\t\t\t\tm.splitMesh(p, s);\r\n\t\t\t}\r\n\t\t\tthis.#cells.push(m);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates the Voronoi cells by splitting initial cells based on adjacency\r\n\t * and weight tables.\r\n\t *\r\n\t * @param adjTab - Optional adjacency table for the sites.\r\n\t * @param weiTab - Optional weight table that influences partitioning.\r\n\t */\r\n\t#divide3(adjTab: number[][], weiTab: number[][]): void {\r\n\t\tfor (const [i, s] of this.#sites.entries()) {\r\n\t\t\t// Creates initial cells as regular hexahedrons.\r\n\t\t\tconst m: Mesh = Mesh.buildMesh(this.#defaultVs, Voronoi.FACE_INDEXES);\r\n\r\n\t\t\tconst as: number[] = adjTab[i];\r\n\t\t\tconst ws: number[] = weiTab[i];\r\n\r\n\t\t\tfor (let j: number = 0; j < as.length; ++j) {\r\n\t\t\t\tconst t: Vertex = this.#sites[as[j]];\r\n\t\t\t\tconst p: Plane = new Plane(intDiv(s, t, ws[j]), sub(s, t));\r\n\t\t\t\tm.splitMesh(p, s);\r\n\t\t\t}\r\n\t\t\tthis.#cells.push(m);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Counts a grid of points within a specified cell at a given resolution.\r\n\t *\r\n\t * @param index - The index of the cell for which to calculate grid points.\r\n\t * @param resolution - The spacing between grid points.\r\n\t * @returns Count of the points.\r\n\t */\r\n\tcountGrids(index: number, resolution: number): number {\r\n\t\tlet ret : number = 0;\r\n\r\n\t\tconst norm: Vertex = [0, 0, 1];\r\n\t\tconst s   : Vertex = this.#sites[index];\r\n\t\tconst c   : Mesh   = this.#cells[index];\r\n\r\n\t\tconst f: Face | null = c.crossSection([0, 0, s[2]], norm);\r\n\t\tif (f) {\r\n\t\t\tconst pc: number = f.countGridPoints(s[0], s[1], resolution);\r\n\t\t\tret += pc;\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst f: Face | null = c.crossSection([0, 0, s[2] + inc * resolution], norm);\r\n\t\t\tif (!f) break;\r\n\t\t\tconst pc: number = f.countGridPoints(s[0], s[1], resolution);\r\n\t\t\tif (!pc) break;\r\n\t\t\tret += pc;\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst f: Face | null = c.crossSection([0, 0, s[2] - inc * resolution], norm);\r\n\t\t\tif (!f) break;\r\n\t\t\tconst pc: number = f.countGridPoints(s[0], s[1], resolution);\r\n\t\t\tif (!pc) break;\r\n\t\t\tret += pc;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates a grid of points within a specified cell at a given resolution.\r\n\t *\r\n\t * @param index - The index of the cell for which to calculate grid points.\r\n\t * @param resolution - The spacing between grid points.\r\n\t * @returns A list of 3D coordinates representing grid points within the cell.\r\n\t */\r\n\tgetGrids(index: number, resolution: number): Vertex[] {\r\n\t\tconst ret : Vertex[] = [];\r\n\r\n\t\tconst norm: Vertex = [0, 0, 1];\r\n\t\tconst s   : Vertex = this.#sites[index];\r\n\t\tconst c   : Mesh   = this.#cells[index];\r\n\r\n\t\tconst f: Face | null = c.crossSection([0, 0, s[2]], norm);\r\n\t\tif (f) {\r\n\t\t\tret.push(...f.getGridPoints(s[0], s[1], resolution));\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst f: Face | null = c.crossSection([0, 0, s[2] + inc * resolution], norm);\r\n\t\t\tif (!f) break;\r\n\t\t\tconst ps: Vertex[] = f.getGridPoints(s[0], s[1], resolution);\r\n\t\t\tif (!ps.length) break;\r\n\t\t\tret.push(...ps);\r\n\t\t}\r\n\t\tfor (let inc: number = 1; ; ++inc) {\r\n\t\t\tconst f: Face | null = c.crossSection([0, 0, s[2] - inc * resolution], norm);\r\n\t\t\tif (!f) break;\r\n\t\t\tconst ps: Vertex[] = f.getGridPoints(s[0], s[1], resolution);\r\n\t\t\tif (!ps.length) break;\r\n\t\t\tret.push(...ps);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n}\r\n"],
  "mappings": "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",
  "names": ["add", "a", "b", "sub", "intDiv", "m", "n", "Plane", "_Plane", "#A", "#B", "#C", "#D", "p0", "p1", "len", "p", "t", "vs", "sides", "v", "#intersection", "v0", "v1", "d", "u", "es", "ret", "e", "Edge", "#bgn", "#end", "v", "Face", "_Face", "#firstEdge", "es", "i", "ret", "e", "refSide", "vertToSide", "edgeToInter", "v", "cx", "cy", "resolution", "pc", "#countInternalPoints", "inc", "ips", "#getIntersectionPoints", "x0", "x1", "s", "x", "z", "ps", "#getInternalPoints", "y", "pts", "xs", "#getIntersection", "#removeDuplicates", "y0", "y1", "A", "B", "C", "vs", "a", "b", "res", "cur", "Mesh", "_Mesh", "#vs", "#es", "#fs", "vs", "faceIndex", "m", "v", "vis", "faceEs", "vi", "Edge", "Face", "#pairEdges", "es", "e0", "e1", "p", "site", "siteSide", "edgeToInter", "sides", "newVs", "newEs", "newFs", "f", "newFaceVs", "unpairedEs", "e", "#createFaceEdgesFromUnpairedEdges", "org", "norm", "Plane", "add", "next", "ne", "Voronoi", "_Voronoi", "#defaultVs", "#sites", "#cells", "x0", "x1", "y0", "y1", "z0", "z1", "site", "adjacencyTable", "weightTable", "#divide1", "#divide2", "#divide3", "s", "m", "Mesh", "p", "Plane", "intDiv", "sub", "adjTab", "i", "a", "t", "weiTab", "as", "ws", "j", "index", "resolution", "ret", "norm", "c", "f", "pc", "inc", "ps"]
}
