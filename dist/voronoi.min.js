function M(f,e){return[f[0]+e[0],f[1]+e[1],f[2]+e[2]]}function x(f,e){return[f[0]-e[0],f[1]-e[1],f[2]-e[2]]}function E(f,e,n=.5){let t=1-n;return[f[0]*t+e[0]*n,f[1]*t+e[1]*n,f[2]*t+e[2]*n]}var b=class f{static E=.001;#e;#t;#n;#r;constructor(e,n){let t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);this.#e=n[0]/t,this.#t=n[1]/t,this.#n=n[2]/t,this.#r=-this.#e*e[0]-this.#t*e[1]-this.#n*e[2]}side(e){let n=this.#e*e[0]+this.#t*e[1]+this.#n*e[2]+this.#r;return n<-f.E?-1:n>f.E?1:0}sides(e){let n=new Map;for(let t of e)n.set(t,this.side(t));return n}#s(e,n){let t=this.#e*(e[0]-n[0])+this.#t*(e[1]-n[1])+this.#n*(e[2]-n[2]);if(Math.abs(t)<.001)return null;let r=(this.#e*e[0]+this.#t*e[1]+this.#n*e[2]+this.#r)/t;return r<0||1<r?null:[e[0]+r*(n[0]-e[0]),e[1]+r*(n[1]-e[1]),e[2]+r*(n[2]-e[2])]}intersections(e){let n=new Map;for(let t of e){if(n.has(t))continue;let r=this.#s(t.getBegin(),t.getEnd());r&&(n.set(t,r),t.pair&&n.set(t.pair,r))}return n}};var d=class{#e;#t;next=null;pair=null;constructor(e){this.#e=e}setNext(e){this.next=e,this.#t=e.#e}getBegin(){return this.#e}getEnd(){return this.#t}};var h=class f{static E=.001;#e;constructor(e){let n=e.length;for(let t=0;t<n-1;++t)e[t].setNext(e[t+1]);e[n-1].setNext(e[0]),this.#e=e[0]}length(){let e=0,n=this.#e;do e+=1,n=n.next;while(n!==this.#e);return e}verticesOf(e,n,t){let r=[],s=this.#e;do{let i=s.getBegin();n.get(i)*e>=0&&r.push(i),t.has(s)&&r.push(t.get(s)),s=s.next}while(s!==this.#e);return r}countGridPoints(e,n,t){let r=0,s=this.#t(e,n,t);r+=s;for(let i=1;;++i){let o=this.#t(e,n+i*t,t);if(o===0)break;r+=o}for(let i=1;;++i){let o=this.#t(e,n-i*t,t);if(o===0)break;r+=o}return r}#t(e,n,t){let r=this.#r(n),[s,i]=r;s>i&&([s,i]=[i,s]);let o=0;s<e&&e<i&&(o+=1);for(let u=1;;++u){let m=o,c=e+u*t;if(s<c&&c<i&&(o+=1),o===m)break}for(let u=1;;++u){let m=o,c=e-u*t;if(s<c&&c<i&&(o+=1),o===m)break}return o}getGridPoints(e,n,t){let r=[],s=this.#e.getBegin()[2],i=this.#n(e,n,t);for(let o of i)r.push([o,n,s]);for(let o=1;;++o){let u=n+o*t,m=this.#n(e,u,t);if(m.length===0)break;for(let c of m)r.push([c,u,s])}for(let o=1;;++o){let u=n-o*t,m=this.#n(e,u,t);if(m.length===0)break;for(let c of m)r.push([c,u,s])}return r}#n(e,n,t){let r=this.#r(n),[s,i]=r;s>i&&([s,i]=[i,s]);let o=[];s<e&&e<i&&o.push(e);for(let u=1;;++u){let m=o.length,c=e+u*t;if(s<c&&c<i&&o.push(c),o.length===m)break}for(let u=1;;++u){let m=o.length,c=e-u*t;if(s<c&&c<i&&o.push(c),o.length===m)break}return o}#r(e){let n=[];for(let t=this.#e;;t=t.next){let r=f.#s(t,e);if(n.push(...r),t.next===this.#e)break}return f.#i(n)}static#s(e,n){let[t,r]=e.getBegin(),[s,i]=e.getEnd();if(n<Math.min(r,i)||Math.max(r,i)<n)return[];if(Math.abs(r-i)<f.E)return[t,s];let o=i-r,u=-(s-t),m=-o*t-u*r;return Math.abs(o)<f.E?[]:[-(u*n+m)/o]}static#i(e){if(e.length===0)return[];e.sort((r,s)=>r-s);let n=[],t=e[0];for(let r=1;r<e.length;r++)f.E<e[r]-e[r-1]&&(n.push(t),t=e[r]);return n.push(t),n}};var a=class f{#e=[];#t=[];#n=[];static buildMesh(e,n){let t=new f;for(let r of e)t.#e.push([...r]);for(let r of n){let s=[];for(let i of r)s.push(new d(t.#e[i]));t.#t.push(...s),t.#n.push(new h(s))}return f.#r(t.#t),t}static#r(e){for(let n of e)if(n.pair===null){for(let t of e)if(!(n===t||t.pair!==null)&&n.getBegin()===t.getEnd()&&t.getBegin()===n.getEnd()){n.pair=t,t.pair=n;break}}}constructor(){}splitMesh(e,n){let t=e.side(n);if(t===0)return;let r=e.intersections(this.#t);if(r.size===0)return;let s=e.sides(this.#e),i=[],o=[],u=[];for(let c of this.#n){let p=c.verticesOf(t,s,r);if(p.length<=2)continue;let l=[];for(let g of p)i.includes(g)||i.push(g),l.push(new d(g));o.push(...l),u.push(new h(l))}f.#r(o);let m=o.filter(c=>c.pair===null);if(m.length>0){let c=f.#s(m);o.push(...c),u.push(new h(c))}this.#e=i,this.#n=u,this.#t=o}crossSection(e,n){let t=new b(e,n),r=t.side(M(e,n));if(r===0)return null;let s=t.intersections(this.#t);if(s.size===0)return null;let i=t.sides(this.#e),o=[],u=[];for(let c of this.#n){let p=c.verticesOf(r,i,s);if(p.length<=2)continue;let l=[];for(let g of p)l.push(new d(g));o.push(...l),u.push(new h(l))}f.#r(o);let m=o.filter(c=>c.pair===null);if(m.length>0){let c=f.#s(m);if(c.length>2)return new h(c)}return null}static#s(e){let n=[],t=e[0];do{if(t.next===null)break;let r=t.next;for(;r&&!e.includes(r);)r=r.pair.next;let s=new d(r.getBegin());n.push(s),s.pair=t,t.pair=s,t=r}while(t!==e[0]);return n.reverse(),n}};var V=class f{static FACE_INDEXES=[[0,1,2,3],[1,0,4,5],[0,3,7,4],[2,1,5,6],[5,4,7,6],[3,2,6,7]];#e;#t=[];#n=[];constructor(e,n,t,r,s,i){this.#e=[[n,r,i],[e,r,i],[e,r,s],[n,r,s],[n,t,i],[e,t,i],[e,t,s],[n,t,s]]}addSite(e){this.#t.push([...e])}createCells(e=null,n=null){this.#n.length=0,!e&&!n?this.#r():e&&!n?this.#s(e):e&&n&&this.#i(e,n)}#r(){for(let e of this.#t){let n=a.buildMesh(this.#e,f.FACE_INDEXES);for(let t of this.#t){if(e===t)continue;let r=new b(E(e,t),x(e,t));n.splitMesh(r,e)}this.#n.push(n)}}#s(e){for(let[n,t]of this.#t.entries()){let r=a.buildMesh(this.#e,f.FACE_INDEXES);for(let s of e[n]){let i=this.#t[s],o=new b(E(t,i),x(t,i));r.splitMesh(o,t)}this.#n.push(r)}}#i(e,n){for(let[t,r]of this.#t.entries()){let s=a.buildMesh(this.#e,f.FACE_INDEXES),i=e[t],o=n[t];for(let u=0;u<i.length;++u){let m=this.#t[i[u]],c=new b(E(r,m,o[u]),x(r,m));s.splitMesh(c,r)}this.#n.push(s)}}countGrids(e,n){let t=0,r=[0,0,1],s=this.#t[e],i=this.#n[e],o=i.crossSection([0,0,s[2]],r);if(o){let u=o.countGridPoints(s[0],s[1],n);t+=u}for(let u=1;;++u){let m=i.crossSection([0,0,s[2]+u*n],r);if(!m)break;let c=m.countGridPoints(s[0],s[1],n);if(!c)break;t+=c}for(let u=1;;++u){let m=i.crossSection([0,0,s[2]-u*n],r);if(!m)break;let c=m.countGridPoints(s[0],s[1],n);if(!c)break;t+=c}return t}getGrids(e,n){let t=[],r=[0,0,1],s=this.#t[e],i=this.#n[e],o=i.crossSection([0,0,s[2]],r);o&&t.push(...o.getGridPoints(s[0],s[1],n));for(let u=1;;++u){let m=i.crossSection([0,0,s[2]+u*n],r);if(!m)break;let c=m.getGridPoints(s[0],s[1],n);if(!c.length)break;t.push(...c)}for(let u=1;;++u){let m=i.crossSection([0,0,s[2]-u*n],r);if(!m)break;let c=m.getGridPoints(s[0],s[1],n);if(!c.length)break;t.push(...c)}return t}};export{V as Voronoi};
//# sourceMappingURL=voronoi.min.js.map
