function M(h,e){return[h[0]+e[0],h[1]+e[1],h[2]+e[2]]}function x(h,e){return[h[0]-e[0],h[1]-e[1],h[2]-e[2]]}function E(h,e,n=.5){let t=1-n;return[h[0]*t+e[0]*n,h[1]*t+e[1]*n,h[2]*t+e[2]*n]}var d=class{#t;#e;#n;#r;constructor(e,n){let t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);this.#t=n[0]/t,this.#e=n[1]/t,this.#n=n[2]/t,this.#r=-this.#t*e[0]-this.#e*e[1]-this.#n*e[2]}side(e){let n=this.#t*e[0]+this.#e*e[1]+this.#n*e[2]+this.#r;return n<-.001?-1:n>.001?1:0}sides(e){let n=new Map;for(let t of e)n.set(t,this.side(t));return n}#s(e,n){let t=this.#t*(e[0]-n[0])+this.#e*(e[1]-n[1])+this.#n*(e[2]-n[2]);if(Math.abs(t)<.001)return null;let r=(this.#t*e[0]+this.#e*e[1]+this.#n*e[2]+this.#r)/t;return r<0||1<r?null:[e[0]+r*(n[0]-e[0]),e[1]+r*(n[1]-e[1]),e[2]+r*(n[2]-e[2])]}intersections(e){let n=new Map;for(let t of e){if(n.has(t))continue;let r=this.#s(t.getBegin(),t.getEnd());r&&(n.set(t,r),t.pair&&n.set(t.pair,r))}return n}};var a=class{#t;#e;next=null;pair=null;constructor(e){this.#t=e}setNext(e){this.next=e,this.#e=e.#t}getBegin(){return this.#t}getEnd(){return this.#e}};var g=class{#t;constructor(e){let n=e.length;for(let t=0;t<n-1;++t)e[t].setNext(e[t+1]);e[n-1].setNext(e[0]),this.#t=e[0]}length(){let e=0,n=this.#t;do e+=1,n=n.next;while(n!==this.#t);return e}verticesOf(e,n,t){let r=[],s=this.#t;do{let i=s.getBegin();n.get(i)*e>=0&&r.push(i),t.has(s)&&r.push(t.get(s)),s=s.next}while(s!==this.#t);return r}countGridPoints(e,n,t){let r=0,s=this.#e(e,n,t);for(let i of s)r+=1;for(let i=1;;++i){let o=r,c=this.#e(e,n+i*t,t);for(let u of c)r+=1;let f=this.#e(e,n-i*t,t);for(let u of f)r+=1;if(r===o)break}return r}getGridPoints(e,n,t){let r=[],s=this.#t.getBegin()[2],i=this.#e(e,n,t);for(let o of i)r.push([o,n,s]);for(let o=1;;++o){let c=r.length,f=n+o*t,u=this.#e(e,f,t);for(let l of u)r.push([l,f,s]);let m=n+-o*t,b=this.#e(e,m,t);for(let l of b)r.push([l,m,s]);if(r.length===c)break}return r}#e(e,n,t){let r=[],s=this.#n(n);if(s.length!==2)return r;let i=s[0],o=s[1];i>o&&([i,o]=[o,i]),i<e&&e<o&&r.push(e);for(let c=1;;++c){let f=r.length,u=e+c*t;i<u&&u<o&&r.push(u);let m=e+-c*t;if(i<m&&m<o&&r.push(m),r.length===f)break}return r}#n(e){let n=[];for(let t=this.#t;;t=t.next){let r=this.#r(t,e);if(Number.isNaN(r)||n.push(r),t.next===this.#t)break}return n}#r(e,n){let t=e.getBegin(),r=e.getEnd();if(n<Math.min(t[1],r[1])||Math.max(t[1],r[1])<n)return Number.NaN;let s=r[1]-t[1],i=-(r[0]-t[0]),o=-s*t[0]-i*t[1];return Math.abs(s)<1e-4?Number.NaN:-(i*n+o)/s}};var p=class h{#t=[];#e=[];#n=[];static buildMesh(e,n){let t=new h;for(let r of e)t.#t.push([...r]);for(let r of n){let s=[];for(let i of r)s.push(new a(t.#t[i]));t.#e.push(...s),t.#n.push(new g(s))}return h.#r(t.#e),t}static#r(e){for(let n of e)if(n.pair===null){for(let t of e)if(!(n===t||t.pair!==null)&&n.getBegin()===t.getEnd()&&t.getBegin()===n.getEnd()){n.pair=t,t.pair=n;break}}}constructor(){}splitMesh(e,n){let t=e.side(n);if(t===0)return;let r=e.intersections(this.#e);if(r.size===0)return;let s=e.sides(this.#t),i=[],o=[],c=[];for(let u of this.#n){let m=u.verticesOf(t,s,r);if(m.length<=2)continue;let b=[];for(let l of m)i.includes(l)||i.push(l),b.push(new a(l));o.push(...b),c.push(new g(b))}h.#r(o);let f=o.filter(u=>u.pair===null);if(f.length>0){let u=h.#s(f);o.push(...u),c.push(new g(u))}this.#t=i,this.#n=c,this.#e=o}crossSection(e,n){let t=new d(e,n),r=t.side(M(e,n));if(r===0)return null;let s=t.intersections(this.#e);if(s.size===0)return null;let i=t.sides(this.#t),o=[],c=[];for(let u of this.#n){let m=u.verticesOf(r,i,s);if(m.length<=2)continue;let b=[];for(let l of m)b.push(new a(l));o.push(...b),c.push(new g(b))}h.#r(o);let f=o.filter(u=>u.pair===null);if(f.length>0){let u=h.#s(f);if(u.length>2)return new g(u)}return null}static#s(e){let n=[],t=e[0];do{if(t.next===null)break;let r=t.next;for(;r&&!e.includes(r);)r=r.pair.next;let s=new a(r.getBegin());n.push(s),s.pair=t,t.pair=s,t=r}while(t!==e[0]);return n.reverse(),n}};var V=class h{static FACE_INDEXES=[[0,1,2,3],[1,0,4,5],[0,3,7,4],[2,1,5,6],[5,4,7,6],[3,2,6,7]];#t;#e=[];#n=[];constructor(e,n,t,r,s,i){this.#t=[[n,r,i],[e,r,i],[e,r,s],[n,r,s],[n,t,i],[e,t,i],[e,t,s],[n,t,s]]}addSite(e){this.#e.push([...e])}createCells(e=null,n=null){this.#n.length=0,!e&&!n?this.#r():e&&!n?this.#s(e):e&&n&&this.#i(e,n)}#r(){for(let e of this.#e){let n=p.buildMesh(this.#t,h.FACE_INDEXES);for(let t of this.#e){if(e===t)continue;let r=new d(E(e,t),x(e,t));n.splitMesh(r,e)}this.#n.push(n)}}#s(e){for(let[n,t]of this.#e.entries()){let r=p.buildMesh(this.#t,h.FACE_INDEXES);for(let s of e[n]){let i=this.#e[s],o=new d(E(t,i),x(t,i));r.splitMesh(o,t)}this.#n.push(r)}}#i(e,n){for(let[t,r]of this.#e.entries()){let s=p.buildMesh(this.#t,h.FACE_INDEXES),i=e[t],o=n[t];for(let c=0;c<i.length;++c){let f=this.#e[i[c]],u=new d(E(r,f,o[c]),x(r,f));s.splitMesh(u,r)}this.#n.push(s)}}countGrids(e,n){let t=0,r=[0,0,1],s=this.#e[e],i=this.#n[e],o=i.crossSection([0,0,s[2]],r);if(o){let c=o.countGridPoints(s[0],s[1],n);t+=c}for(let c=1;;++c){let f=i.crossSection([0,0,s[2]+c*n],r);if(!f)break;let u=f.countGridPoints(s[0],s[1],n);if(!u)break;t+=u}for(let c=1;;++c){let f=i.crossSection([0,0,s[2]-c*n],r);if(!f)break;let u=f.countGridPoints(s[0],s[1],n);if(!u)break;t+=u}return t}getGrids(e,n){let t=[],r=[0,0,1],s=this.#e[e],i=this.#n[e],o=i.crossSection([0,0,s[2]],r);o&&t.push(...o.getGridPoints(s[0],s[1],n));for(let c=1;;++c){let f=i.crossSection([0,0,s[2]+c*n],r);if(!f)break;let u=f.getGridPoints(s[0],s[1],n);if(!u.length)break;t.push(...u)}for(let c=1;;++c){let f=i.crossSection([0,0,s[2]-c*n],r);if(!f)break;let u=f.getGridPoints(s[0],s[1],n);if(!u.length)break;t.push(...u)}return t}};export{V as Voronoi};
//# sourceMappingURL=voronoi.min.js.map
